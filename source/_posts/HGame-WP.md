---
title: HGame 2023 WP
date: 2023-01-14 22:29:45
tags:
---

# Week1 个人 WP

要过年了，天天被拉去给家里干活，没多少时间打

## RE

### easyasm

汇编不太熟，但是一眼xor

```python
data = [0x5b,0x54,0x52,0x5e,0x56,0x48,0x44,0x56,0x5f,0x50,0x3,0x5e,0x56,0x6c,0x47,
                     0x3,0x6c,0x41,0x56,0x6c,0x44,0x5c,0x41,0x2,0x57,0x12,0x4e]
for i in data:
    print(chr(i^0x33),end='')
```

### easyenc

IDA分析：

![](/images/post_imgs/hgame_easyenc_ida.jpg)

从代码能看出，v8和v9存的是加密数据(在内存中连续)，而v10存的是scanf接受的字符串。

不难看出flag长度为41，而while中的代码与以下代码功能相同

```c
while(1) {
    v10[v3] = (v10[v3] ^ 0x32) - 86;
    if(v8[v3] != v10[v3]) break;
}
```

其实就是简单异或后比较是否与加密数据相同，逆运算写出解密脚本：

```python
data = [0x04, 0xFF, 0xFD, 0x09, 0x01, 0xF3, 0xB0, 0x00, 0x00, 0x05, 0xF0, 0xAD, 0x07, 0x06, 0x17, 0x05, 
    0xEB, 0x17, 0xFD, 0x17, 0xEA, 0x01, 0xEE, 0x01, 0xEA, 0xB1, 0x05, 0xFA, 0x08, 0x01, 0x17, 0xAC, 
    0xEC, 0x01, 0xEA, 0xFD, 0xF0, 0x05, 0x07, 0x06, 0xF9]

for i in data:
    print(chr(((i+86)^0x32)&0xFF), end='')
```

智力退化了，我一开始忘了&0xff，结果出来有乱码，还以为分析错了

### encode

IDA分析：

![](/images/post_imgs/hgame_encode_ida.jpg)

分析可知用户输入flag存到v5，然后将flag每个字节的前后半字分开储存到v4，得到加密后的数据v4与常量数组dword_403000进行比对。

直接提取出dword_403000的数据然后拼回字节就行了

解题脚本：

```c
#include <stdio.h>

int main()
{
    unsigned int cmp_data[100] = {
        0x00000008, 0x00000006, 0x00000007, 0x00000006, 0x00000001, 0x00000006, 0x0000000D, 0x00000006,
        0x00000005, 0x00000006, 0x0000000B, 0x00000007, 0x00000005, 0x00000006, 0x0000000E, 0x00000006,
        0x00000003, 0x00000006, 0x0000000F, 0x00000006, 0x00000004, 0x00000006, 0x00000005, 0x00000006,
        0x0000000F, 0x00000005, 0x00000009, 0x00000006, 0x00000003, 0x00000007, 0x0000000F, 0x00000005,
        0x00000005, 0x00000006, 0x00000001, 0x00000006, 0x00000003, 0x00000007, 0x00000009, 0x00000007,
        0x0000000F, 0x00000005, 0x00000006, 0x00000006, 0x0000000F, 0x00000006, 0x00000002, 0x00000007,
        0x0000000F, 0x00000005, 0x00000001, 0x00000006, 0x0000000F, 0x00000005, 0x00000002, 0x00000007,
        0x00000005, 0x00000006, 0x00000006, 0x00000007, 0x00000005, 0x00000006, 0x00000002, 0x00000007,
        0x00000003, 0x00000007, 0x00000005, 0x00000006, 0x0000000F, 0x00000005, 0x00000005, 0x00000006,
        0x0000000E, 0x00000006, 0x00000007, 0x00000006, 0x00000009, 0x00000006, 0x0000000E, 0x00000006,
        0x00000005, 0x00000006, 0x00000005, 0x00000006, 0x00000002, 0x00000007, 0x0000000D, 0x00000007,
        0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
        0x00000000, 0x00000000, 0x00000000, 0x00000000};
    
    for (int i = 0; i < 50; ++i)
    {
        //v4[2 * i] = input[i] & 0xF;
        printf("%c", (char)(cmp_data[2 * i] + (cmp_data[2 * i + 1] << 4)));
        //v4[2 * i + 1] = (input[i] >> 4) & 0xF;
    }
}
```

### a_cup_of_tea

经典tea，先IDA分析：

![](/images/post_imgs/hgame_tea_ida.jpg)

buf2与v8存的是加密数据，buf1存了用户输入的flag，然后buf1各段分四次与a2传入tea函数

tea函数长这样：

![](/images/post_imgs/tea_func.jpg)

因为xor有那特殊的性质，这里直接把代码改改倒过去算就能还原明文了。a2不知道是个什么东西，但是通过动态调试可以发现其规律

v2=0x12345678
v4=0x23456789
v5=0x34567890
\.\.\.

解题脚本：

```c
#include <stdio.h>

int tea(unsigned int *p)
{
    int v2 = 0x12345678;
    int v3 = 0x79BDE460;
    //int v3 = 0;
    int v4 = 0x23456789;
    int v5 = 0x34567890;
    int v6 = 0x45678901;
    unsigned int v7 = *p;
    int v8 = 32;
    unsigned int v9 = p[1];
    
//   do
//   {
//     v3 -= 1412567261;
//     v7 += (v3 + v9) ^ (v2 + 16 * v9) ^ (v4 + (v9 >> 5));
//     v9 += (v3 + v7) ^ (v5 + 16 * v7) ^ (v6 + (v7 >> 5));
//     --v8;
//   }
//   while ( v8 );

     do {
        --v8;
        v9 -= (v3 + v7) ^ (v5 + 16 * v7) ^ (v6 + (v7 >> 5));
        v7 -=  (v3 + v9) ^ (v2 + 16 * v9) ^ (v4 + (v9 >> 5));
        v3 += 1412567261;     
    } while(v8);

    *p = v7;
    p[1] = v9;
}

int main()
{
    unsigned char data[34] = {
    0x9D, 0x82, 0x63, 0x2E, 0x0F, 0x40, 0x4E, 0xC1, 0xB9, 0xBF, 0x39, 0x9B, 0x14, 0x8B, 0x1F, 0x5A, 
    0xDE, 0x6D, 0x88, 0x61, 0xCF, 0xC6, 0x65, 0x65, 0x64, 0x4F, 0x06, 0x9F, 0xF6, 0x43, 0x6A, 0x23, 
    0x6B, 0x7D
    };

    tea(&data[24]);
    tea(&data[16]);
    tea(&data[8]);
    tea(data);
    for(int i = 0;i < 34;i++){
        printf("%c", data[i]);
    }
}
```

## Crypto

### rsa

这题要用一个网站分解n得到p q，然后根据rsa算法解开

```python
import gmpy2
from binascii import a2b_hex
# p q由n因式分解得到
p = 11239134987804993586763559028187245057652550219515201768644770733869088185320740938450178816138394844329723311433549899499795775655921261664087997097294813
q = 12022912661420941592569751731802639375088427463430162252113082619617837010913002515450223656942836378041122163833359097910935638423464006252814266959128953
n = 135127138348299757374196447062640858416920350098320099993115949719051354213545596643216739555453946196078110834726375475981791223069451364024181952818056802089567064926510294124594174478123216516600368334763849206942942824711531334239106807454086389211139153023662266125937481669520771879355089997671125020789
e = 65537
c = 110674792674017748243232351185896019660434718342001686906527789876264976328686134101972125493938434992787002915562500475480693297360867681000092725583284616353543422388489208114545007138606543678040798651836027433383282177081034151589935024292017207209056829250152219183518400364871109559825679273502274955582
fn = (p - 1) * (q - 1)
d = gmpy2.invert(e, fn)
h = hex(gmpy2.powmod(c, d, n))[2:] #去掉"0x"
if len(h) % 2 == 1: #补齐位数
    h = '0' + h
s = bytes(h, 'ascii')
t = a2b_hex(s)
print(t.decode())
```
